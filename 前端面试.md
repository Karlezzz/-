# 面试



## 浏览器

###### 如何理解 JS 的异步？

JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。

而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。

如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。

所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。

在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。



###### JS 中的计时器能做到精确计时吗？为什么？

不行，因为：

1. 计算机硬件没有原子钟，无法做到精确计时
2. 操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差
3. 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差
4. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差



#### 页面渲染

###### 浏览器是如何渲染页面的？

当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。

在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。

-------

整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画

每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。

这样，整个渲染流程就形成了一套组织严密的生产流水线。

-------

渲染的第一步是**解析 HTML**。

解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。

如果主线程解析到`link`位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。

如果主线程解析到`script`位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。

第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。

-------

渲染的下一步是**样式计算**。

主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。

在这一过程中，很多预设值会变成绝对值，比如`red`会变成`rgb(255,0,0)`；相对单位会变成绝对单位，比如`em`会变成`px`

这一步完成后，会得到一棵带有样式的 DOM 树。

--------

接下来是**布局**，布局完成后会得到布局树。

布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。

大部分时候，DOM 树和布局树并非一一对应。

比如`display:none`的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有**匿名行盒、匿名块盒**等等都会导致 DOM 树和布局树无法一一对应。

-----------

下一步是**分层**

主线程会使用一套复杂的策略对整个布局树中进行分层。

分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。

滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过`will-change`属性更大程度的影响分层结果。

---------

再下一步是**绘制**

主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。

------

完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。

合成线程首先对每个图层进行**分块**，将其划分为更多的小区域。

它会从线程池中拿取多个线程来完成分块工作。

----

分块完成后，进入**光栅化**阶段。

合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。

GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。

光栅化的结果，就是一块一块的位图

---------

最后一个阶段就是**画**了

合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。

指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。

变形发生在合成线程，与渲染主线程无关，这就是`transform`效率高的本质原因。

合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。

![image-20230321141026078](C:\Users\Karle\AppData\Roaming\Typora\typora-user-images\image-20230321141026078.png)

###### 什么是 reflow？

reflow 的本质就是重新计算 layout 树。

当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。

为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。

也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。

浏览器在反复权衡下，最终决定获取属性立即 reflow。



###### 什么是 repaint？

repaint 的本质就是重新根据分层信息计算了绘制指令。

当改动了可见样式后，就需要重新计算，会引发 repaint。

由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。



###### 为什么 transform 的效率高？

因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段

由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。



#### 消息队列

- 延时队列：用于存放计时器到达后的回调任务，优先级「中」

- 交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」

- 微队列：用户存放需要最快执行的任务，优先级「最高」

  解析

  1.从上到下解读 遇到普通语句和Promise内部语句放main

  2.遇到Promise.then() Promise.resolve() 内语句放微队列

  3.遇到延时任务放延时队列

  4.遇到用户事件放交互队列

  5.mian执行完前面，再执行其他队列的任务块

  ```javascript
  例1：
  setTimeout(() => {
    console.log('timer_1');
    setTimeout(() => {
      console.log('timer_3')
    }, 0) 
    new Promise(resolve => {
      resolve()
      console.log('new promise')
    }).then(() => {
      console.log('promise then')
    })
  }, 0)
  
  setTimeout(() => {
    console.log('timer_2')
  }, 0)
  
  console.log('end')
  
  //end
  //timer_1
  //new Promise
  //promise then
  //timer_2
  //timer_3
  
  例2：
  <div class="outer">
      <div class="inner"></div>
    </div>
  
  var outer = document.querySelector('.outer');
  var inner = document.querySelector('.inner');
  
    function onClick() {
      console.log('inner');
  
      setTimeout(function () {
        console.log('inner-timeout');
      }, 0);
  
      Promise.resolve().then(function () {
        console.log('inner-promise');
      });
  
    }
    function onClick2() {
      console.log('outer');
  
      setTimeout(function () {
        console.log('outer-timeout');
      }, 0);
  
      Promise.resolve().then(function () {
        console.log('outer-promise');
      });
  
    }
  
    inner.addEventListener('click', onClick);
    outer.addEventListener('click', onClick2);
  
  // inner
  // inner-promise
  // outer
  // outer-promise
  // inner-timeout
  // outer-timeout
  遇到冒泡，一层一层执行。一泡执行完全后再执行下一泡
  
  例三：
  	   async function f1() {
              await f2()
              console.log('f1结束')
          }
          async function f2() {
              await f3()
              console.log('f2结束')
          }
          async function f3() {
              console.log('f3结束')
          }
          f1()
          new Promise(res=>{
              console.log('new Promise')
              res()
          }).then(res=>{
              console.log('promise第一个then')
          }).then(res=>{
              console.log('promise第二个then')
          })
  
  //f3结束
  //new Promise
  //f2结束
  //promise第一个then
  //f1结束
  //promise第二个then
  
  async function f1() {
              //await f2()
              //console.log('f1结束')
          new Promise((resolv,reject)=>resolve(f2())).then(()=>{
               console.log('f1结束')
          })
          }
          async function f2() {
              //await f3()
              //console.log('f2结束')
               new Promise((resolv,reject)=>resolve(f3())).then(()=>{
               console.log('f2结束')
          })
          }
          async function f3() {
              console.log('f3结束')
          }
          f1()
          new Promise(res=>{
              console.log('new Promise')
              res()
          }).then(res=>{
              console.log('promise第一个then')
          }).then(res=>{
              console.log('promise第二个then')
          })
  ```

###### 阐述一下 JS 的事件循环

事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。

在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。

过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。

根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。



#### 垃圾回收机制

##### 	产生

​		1.产生全局变量

​		2.闭包

​		3.没有清理的DOM

​		4.没有清理的定时器

​		5.子元素存在引用

##### 方法

###### 	标记清除

​		变量进入环境被标记“进入”，遍历离开环境被标记“离开”，浏览器清除“离开”的变量

###### 	应用计数

​		





## HTML

#### 语义化标签

#### 块盒、行盒标签

#### H5媒体标签



## JS

#### 预编译 --->>变量声明和函数声明的提升

​	作用域内变量未声明就赋值，成为全局变量，存在window

​	预编译发生在函数执行的前一刻

##### 	步骤  

​		1.创建AO对象（执行上下文对象）（方法内）

​			创建GO对象（全局） 

​		2.找形参和变量声明，将变量和形参名作为AO属性名，值为undefined

​		3.将实参值和形参统一(浅拷贝)

​		4.在函数体内找函数声明，值赋予函数体

```javascript
例子1：
function fn (a){
    console.log(a)
    var a = 123
    console.log(a)
    function a(){}
    console.log(a)
    var b = function(){}
    console.log(b)
    function d(){}
}
fn(1)

1.AO{
    
}
2.AO{
    a:undefined   //var a
    b:undefined   //var b
}
3.AO{
    a:1   //实参a=1
    b:undefined   //var b
}
4.AO{
    a:function a(){}   //function a(){}
    b:undefined   //var b
    d:function d(){}  //function d(){} 
}
5.AO{
    a:123   //a=123
    b:undefined   //var b
    d:function d(){}  //function a(){} 
}
6.AO{
    a:123   //a=123
    b:function(){}   //function(){}
    d:function d(){}  //function d(){} 
}
7.AO{
    a:123   //a=123
    b:function(){}   //function(){}
    d:function d(){}  //function d(){} 
}
-----------------------------------------
例二：
console.log(test)
function test(test){
    console.log(test)
    var test = 234
    console.log(test)
    function test(){}
}
test(1)
var test = 123
// function test(){...}  function test(){}  234

1.GO{
    test:function(){  //var test -> function test(){...}
        ...
    }
}
2.AO{
    test:function(){} //var test -> a= 1 -> function test(){}
}

```



#### 作用域链

##### 	定义

​		[[scope]]中存储的执行上下文对象的集合，呈链式结构。

​		[[scope]]：作用域，存储了执行上下文的集合（存储多个AO和GO）

##### 	产生

​		1. 作用域链可以理解为栈，查询变量都从栈顶出发，每次产生AO都放栈顶

​        2. 函数定义不产生自己的AO，只继承上层函数的AO和GO。当函数被执行，产生自己的AO并入栈。（头层函数被定义时产生GO）

​	    3. 函数执行完毕，自己的AO出栈销毁，释放内存

```javascript
function a(){
    function b(){
        var b = 234
    }
    var a = 123
    b()
}
var global = 100
a()

//a definde: a.[[scope]] --> 0 : GO:{}
//a doing: a.[[scope]] --> 0 : AO:{}
//                         1 : GO:{}
//b definde: a.[[scope]][0] --> b.[[scope]] --> 0 : AO:{}(a.[[scope]]的AO)
//                                       --> 1 : GO:{}(a.[[scope]]的GO)
//b doing: a.[[scope]][0] --> b.[[scope]] --> 0 : AO:{} (b自己的AO)
//                                     --> 1 : AO:{}(a.[[scope]]的AO)
//                                     --> 2 : GO:{}(a.[[scope]]的GO)

```



#### 闭包

##### 	概述

​		内部函数被保存到外部，外部可以访问到内部函数作用域 

```javascript
function a(){
    function b(){}
    var a = 1
    return b
}
var demo = a()
demo()
```

​		a()定义和执行产生GO和aAO，b()被定义后携带GO和aAO，return b导致外部能得到GO和aAO，所以外部可以访问a()的变量

##### 	场景

​		1.实现公有变量（无需定义全局变量，实现全局变量效果）（埋点计数器）

```javascript
function add (){
    var count=0
    function add2(){
        console.log(++count)
    }
    return add2
}
var myAdd = add()
myAdd()//可以循环执行
//因为add2给到全局，使得add()的AO也给到全局，所以变量count不会被垃圾回收，从而实现累加
```

​		2.柯里化（将多参数函数变成单参数函数）

```javascript
// 原函数 用来检验文本是否符合规范
// reg 传入的正则表达式  txt 需要被检测的文本
function check(reg,txt){
	return reg.test(txt)
}
console.log(check(电话号码的正则,13923456789));
console.log(check(邮箱的正则,youxiang@163.com));

// 现如今
function nowCheck(reg){
	return function(txt){
		return reg.test(txt)
	}
}
var isPhone = nowCheck(电话号码的正则)
console.log(isPhone('13923456789'))
var isEmail = nowCheck(邮箱的正则)
console.log(isEmail('youxiang@163.com'))
```

​		3.实现封装，属性私有化

​		4.模块化开发，防止污染全局变量

##### 	缺点

​		因为变量存活周期变长，当内部函数执行后变量不会被垃圾回收机制回收，导致存在内存泄漏的风险

​		导致原有作用域链不释放，造成内存泄漏（可用内存变少）

##### IIFE（立即执行函数）

​		**函数表达式才可以执行，通过数学符号（）将函数声明变成函数表达式，加上（）执行符号，从而执行。**

​		执行完立马销毁

​		w3c标准:`(function (){}())`

​	IIFE解决问题

```javascript
function test(){
    var arr=[]
    for(var i = 0;i<10;i++){
        (function(j){
            arr[j] = function(){
                console.log(j)
            }
        }(i))
    }
    return arr
}
var my = test()
for(var o = 0;o<10;o++){
    my[o]()
}
```



#### 原型链

##### 	原型

​		**对象的一个属性，定义了构造函数制造出的对象的公共祖先。通过构造函数产生的对象，可以继承这个原型的属性和方法。**

​		constructor：`构造函数=new Person()`，可以通过原型修改构造函数 `Person.prototype = { constructor : Car }`

##### 	原型链

​		`构造函数.prototype = 实例对象.__proto__（指向**.prototype）`

​		`*.prototype.__proto__ = Object.prototype`

​		Function:

​			`Function.实例化 = Function`

​			`Function.prototype = Function.__proto__`

​		Object:

​			`Object.实例化 = Object.prototype`

​			`Object.prototype.__proto__ = null`

##### 	特例：所有对象最终都继承`Object.prototype` -----错误

​		`Object.create(原型)` 当`let obj = Object.create(null)`,该对象原型为null

​		

​		

#### call/apply

​	作用：改变this指向

​	区别：参数形式不同

​		call 需要把实参按形参个数传进去

​		apply 需要传一个arguments

##### 		call

```javascript
function Person(name, age, sex){
    this.name = name
    this.age = age
    this.sex = sex
}
function Student(name, age, sex, tel, grade){
    Person.call(this, name, age, sex)
    this.tel = tel 
    this.grade = grade
}
let student = new Student('benny',123,'male',129,2017)
```

##### 		apply

```javascript
function Person(name, age, sex){
    this.name = name
    this.age = age
    this.sex = sex
}
function Student(name, age, sex, tel, grade){
    Person.apply(this, [name, age, sex])
    this.tel = tel 
    this.grade = grade
}
let student = new Student('benny',123,'male',129,2017)
```

​		

#### 类

##### 	定义：对象的模板

##### 	封装：存储属性的同时，要保护数据安全

​		确保数据安全：

​			1.数据私有化 使用 **#** 定义属性

​			2.提供getter和setter 暴露属性

​				一 、控制数据读写权限

​				二 、可以验证修改值

```javascript
class Person{
    #address = 'abc'
    constructor(name){
        this.name = name
    }
    sayHello(){
        consolelog(this.#address)
    }
}
const p1 = new Person('666')
//当属性加上# 外界只能通过内部函数读取该属性，p1.address访问无效
//私有化属性需要先声明再初始话
```

##### 	多态：函数参数不检查类型，将不同对象作为参数

##### 	继承



#### This指向

##### 	绑定规则(优先级 )

​	1  默认绑定规则 ：`this===window`

```javascript
function test(){
    console.log(this)
}
test() //window
```

​	2 隐式绑定规则： 谁执行函数就 指向谁（隐式丢失和参数赋值都会改变这个规则）

```javascript
//隐式丢失 
var a = 0
function foo(){
    console.log(this)
}
var obj = {
    a:2,
    foo:foo
}
obj.foo() //obj
var bar = obj.foo
var bar = foo
bar() //window
foo() //window
//-------------------------------------
//参数赋值
var a = 0
function foo(){
    console.log(this)
}
function bar(fn){
    fn()
}
var obj = {
    a:2,
    foo:foo
}
bar(obj.foo) //window
```

​	3 显式绑定： call  apply   bind  主动改变this指向，参数为新的this

```javascript
//隐式丢失 
var a = 0
function foo(){
    console.log(this)
}
var obj = {
    a:2,
    foo:foo
}
var bar = obj.foo
obj.foo() //obj
bar.call(obj) //obj
bar.apply(obj) //obj
bar.bind(obj)() //obj
```

​	4.new绑定(new 改变 this 指向)

```javascript
function Person(){
    var this={}
    this.a=1
    return this
}
var person = new Person() // this = person
```

​	优先级例子

```javascript
function foo(b){
    this.a = b 
}
var obj1 = {}
var bar = foo.bind（obj1)
bar(2)
console..log(obj1.a) //2
var baz = new bar(3)
console..log(obj1.a) //2 new改变指向到baz，变成baz有a属性
console..log(baz.a) //3 

//new > bind=apply=call
```



#### async/await

#### 

#### 数组操作

#### Promise

#### set map

#### 防抖和节流



## CSS

#### css属性计算过程

##### 确定声明值

##### 层叠冲突

- ###### 比较源的重要性

  - 浏览器默认样式表为**用户代理样式**。
  - 页面作者编写样式为**页面作者样式**。
  - 页面用户在开发者工具修改的样式为**用户样式**。
  - 权重：页面作者样式 > 用户样式 > 用户代理样式

  ###### 比较优先级

  - 权重：id选择器=100    class选择器=10    标签选择器=1
  
    （!important > 内联样式 > ID > class > 标签）
  
  - 选择权重相加最高的样式
  
  ###### 比较次序
  
  - 后样式覆盖前样式

##### 使用继承

- 继承最近的div样式	

##### 使用默认值

- 剩下样式使用默认值



#### 包含块

##### 初始包含块

##### 非根元素包含块

- 如果元素的 positiion 是 relative 或 static ，那么包含块由离它**最近的块容器**的边缘建立。

- 如果 position 属性是 fixed，那么包含块由**视口**建立。

- 如果元素使用了 absolute 定位，则包含块由它的最近的 **position 的值不是 static** （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成

- position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：

  - transform 或 perspective 的值不是 none
  - will-change 的值是 transform 或 perspective 
  - filter 的值不是 none 或 will-change 的值是 filter(只在 Firefox 下生效). 
  - contain 的值是 paint (例如: contain: paint;)

  

#### BFC

##### BFC定义

​	块级格式化上下文，形成独立渲染区域，与外界不相干

​	影响：

​	1.水平margin合并

​	2.BFC中元素做外边距和BFC左边缘重叠

##### BFC生成

- 根元素，即HTML标签
- 浮动元素：float值为left、right
- overflow值不为 visible，为 auto、scroll、hidden
- display值为 inline-block、table-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid
- 定位元素：position值为 absolute、fixed

##### 动画



## VUE

#### 响应式原理

#### diff算法

#### MVVM框架

#### vuex

#### vue-router

#### vue-axios

#### 过渡动画



## HTTP/HTTPS



## Websocket



## Ajax



## Node.js



## 计算机网络



## 操作系统



## Webpack

































































