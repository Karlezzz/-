# 八股文



## 浏览器

#### 如何理解 JS 的异步？

JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。

而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。

如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。

所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。

在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。



#### JS 中的计时器能做到精确计时吗？为什么？

不行，因为：

1. 计算机硬件没有原子钟，无法做到精确计时
2. 操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差
3. 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差
4. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差



#### 页面渲染

###### 浏览器是如何渲染页面的？

当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。

在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。

-------

整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画

每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。

这样，整个渲染流程就形成了一套组织严密的生产流水线。

-------

渲染的第一步是**解析 HTML**。

解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。

如果主线程解析到`link`位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。

如果主线程解析到`script`位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。

第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。

-------

渲染的下一步是**样式计算**。

主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。

在这一过程中，很多预设值会变成绝对值，比如`red`会变成`rgb(255,0,0)`；相对单位会变成绝对单位，比如`em`会变成`px`

这一步完成后，会得到一棵带有样式的 DOM 树。

--------

接下来是**布局**，布局完成后会得到布局树。

布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。

大部分时候，DOM 树和布局树并非一一对应。

比如`display:none`的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有**匿名行盒、匿名块盒**等等都会导致 DOM 树和布局树无法一一对应。

-----------

下一步是**分层**

主线程会使用一套复杂的策略对整个布局树中进行分层。

分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。

滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过`will-change`属性更大程度的影响分层结果。

---------

再下一步是**绘制**

主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。

------

完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。

合成线程首先对每个图层进行**分块**，将其划分为更多的小区域。

它会从线程池中拿取多个线程来完成分块工作。

----

分块完成后，进入**光栅化**阶段。

合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。

GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。

光栅化的结果，就是一块一块的位图

---------

最后一个阶段就是**画**了

合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。

指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。

变形发生在合成线程，与渲染主线程无关，这就是`transform`效率高的本质原因。

合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。

![image-20230321141026078](C:\Users\Karle\AppData\Roaming\Typora\typora-user-images\image-20230321141026078.png)



###### 什么是 reflow？

reflow 的本质就是重新计算 layout 树。

当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。

为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。

也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。

浏览器在反复权衡下，最终决定获取属性立即 reflow。



###### 什么是 repaint？

repaint 的本质就是重新根据分层信息计算了绘制指令。

当改动了可见样式后，就需要重新计算，会引发 repaint。

由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。



###### 为什么 transform 的效率高？

因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段

由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。



#### 消息队列

- 延时队列：用于存放计时器到达后的回调任务，优先级「中」

- 交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」

- 微队列：用户存放需要最快执行的任务，优先级「最高」

  解析

  1.从上到下解读 遇到普通语句和Promise内部语句放main

  2.遇到Promise.then() Promise.resolve() 内语句放微队列

  3.遇到延时任务放延时队列

  4.遇到用户事件放交互队列

  5.mian执行完前面，再执行其他队列的任务块

  ```javascript
  例1：
  setTimeout(() => {
    console.log('timer_1');
    setTimeout(() => {
      console.log('timer_3')
    }, 0) 
    new Promise(resolve => {
      resolve()
      console.log('new promise')
    }).then(() => {
      console.log('promise then')
    })
  }, 0)
  
  setTimeout(() => {
    console.log('timer_2')
  }, 0)
  
  console.log('end')
  
  //end
  //timer_1
  //new Promise
  //promise then
  //timer_2
  //timer_3
  
  例2：
  <div class="outer">
      <div class="inner"></div>
    </div>
  
  var outer = document.querySelector('.outer');
  var inner = document.querySelector('.inner');
  
    function onClick() {
      console.log('inner');
  
      setTimeout(function () {
        console.log('inner-timeout');
      }, 0);
  
      Promise.resolve().then(function () {
        console.log('inner-promise');
      });
  
    }
    function onClick2() {
      console.log('outer');
  
      setTimeout(function () {
        console.log('outer-timeout');
      }, 0);
  
      Promise.resolve().then(function () {
        console.log('outer-promise');
      });
  
    }
  
    inner.addEventListener('click', onClick);
    outer.addEventListener('click', onClick2);
  
  // inner
  // inner-promise
  // outer
  // outer-promise
  // inner-timeout
  // outer-timeout
  遇到冒泡，一层一层执行。一泡执行完全后再执行下一泡
  
  例三：
  	   async function f1() {
              await f2()
              console.log('f1结束')
          }
          async function f2() {
              await f3()
              console.log('f2结束')
          }
          async function f3() {
              console.log('f3结束')
          }
          f1()
          new Promise(res=>{
              console.log('new Promise')
              res()
          }).then(res=>{
              console.log('promise第一个then')
          }).then(res=>{
              console.log('promise第二个then')
          })
  
  //f3结束
  //new Promise
  //f2结束
  //promise第一个then
  //f1结束
  //promise第二个then
  
  async function f1() {
              //await f2()
              //console.log('f1结束')
          new Promise((resolv,reject)=>resolve(f2())).then(()=>{
               console.log('f1结束')
          })
          }
          async function f2() {
              //await f3()
              //console.log('f2结束')
               new Promise((resolv,reject)=>resolve(f3())).then(()=>{
               console.log('f2结束')
          })
          }
          async function f3() {
              console.log('f3结束')
          }
          f1()
          new Promise(res=>{
              console.log('new Promise')
              res()
          }).then(res=>{
              console.log('promise第一个then')
          }).then(res=>{
              console.log('promise第二个then')
          })
  ```

###### 阐述一下 JS 的事件循环

事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。

在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。

过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。

根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。



#### 垃圾回收机制

##### 	产生

​		1.产生全局变量

​		2.闭包

​		3.没有清理的DOM

​		4.没有清理的定时器

​		5.子元素存在引用

##### 方法

###### 	标记清除

​		变量进入环境被标记“进入”，遍历离开环境被标记“离开”，浏览器清除“离开”的变量

###### 	应用计数

​		



## W3C标准

1、 需要声明（DOCTYPE）

DOCTYPE（document type）文档类型的简写，用来说明你用的XHTML或者HTML是什么版本。其中DTD叫文档类型定义，里面包含了文档的规则，浏览器就根据你定义的DTD来解释你页面的标识，并展现出来。

2、需要定义语言编码

`<meta http-equiv=“Content-Type” content=“text/html; charset=gb2312” />`

注：如果忘记了定义语言编码，可能会出现页面乱码现象。

3、JavaScript定义

Js必须要用`<script language="javascript" type="text/javascript">`来开头定义，以保证在不支持js的浏览器上直接显示出来。

4、CSS定义 

CSS必须要用`<style type="text/css">`开头来定义，为保证各浏览器的兼容性，在写CSS时请都写上数量单位

5、使用注释

正确的应用等号或者空格替换内部的虚线。<!--这里是注释============这里是注释-->

6、所有标签的元素和属性名字都必须使用小写

与HTML不一样，XHTML对大小写是敏感的，`<title>`和`<TITLE>`是不同的标签。XHTML要求所有的标签和属性的名字都必须使用小写。

6、所有属性值必须用引号括起来（"" ''）双引号或单引号

7、把所有特殊符号用编码表示

空格为  、小于号（<）<、大于号（>）>、和号（&）&等。

8、所有属性必须有属性值

XHTML规定所有属性都必须有个值，没有值就是重复本身。

9、所有的标记都必须有相应的结束标记

双标记：`<div></div> `单标记：`<img />`

10、所有的标记都必须合理嵌套

11、图片添加有意义的alt属性 

图片加载失败时可以用alt属性表明图片内容。同理添加文字链接的title属性，帮助显示不完整的内容显示完整。

12、在form表单中增加label，以增加用户友好度

```html
<form>
    <labelfor="firstname">first name: </label>
    <inputtype="text" id="firstname"/>
</form>
```



## HTML

### H5新内容

1 语义化标签

2 表单功能增强

3 canvas svg

4 音视频标签

5 拖拽

6 本地存储

7 web worker

8 地理位置

#### 语义化标签 

```html
<header>网页头部</header>
<nav>网页导航</nav>
<aside>侧边栏</aside>
<article>文章区域</article>
<section>区块</section>
<footer>网页底部</footer>
```

#### 块、行、行内块标签

​	行内元素

```html
 <a>     // 标签可定义锚 
 <abbr>     // 表示一个缩写形式 
 <acronym>     // 定义只取首字母缩写 
 <b>     // 字体加粗 
 <bdo>     // 可覆盖默认的文本方向 
 <big>     // 大号字体加粗 
 <br>     // 换行 
 <cite>     // 引用进行定义 
 <code>    // 定义计算机代码文本
 <dfn>     // 定义一个定义项目
 <em>     // 定义为强调的内容
 <i>     // 斜体文本效果
 <kbd>     // 定义键盘文本
 <label>     // 标签为 input 元素定义标注（标记）
 <q>     // 定义短的引用
 <samp>     // 定义样本文本
 <select> // 创建单选或多选菜单
 <small>     // 呈现小号字体效果
 <span>     // 组合文档中的行内元素
 <strong> // 加粗
 <sub>     // 定义下标文本
 <sup>     // 定义上标文本
 <textarea>     // 多行的文本输入控件
 <tt>     // 打字机或者等宽的文本效果
 <var>    // 定义变量

```

块级元素

```html
 <address>  // 定义地址 
 <caption>  // 定义表格标题 
 <dd>      // 定义列表中定义条目 
 <div>     // 定义文档中的分区或节 
 <dl>    // 定义列表 
 <dt>     // 定义列表中的项目 
 <fieldset>  // 定义一个框架集 
 <form>  // 创建 HTML 表单 
 <h1>    // 定义最大的标题
 <h2>    // 定义副标题
 <h3>     // 定义标题
 <h4>     // 定义标题
 <h5>     // 定义标题
 <h6>     // 定义最小的标题
 <hr>     // 创建一条水平线
 <legend>    // 元素为 fieldset 元素定义标题
 <li>     // 标签定义列表项目
 <noframes>    // 为那些不支持框架的浏览器显示文本，于 frameset 元素内部
 <noscript>    // 定义在脚本未被执行时的替代内容
 <ol>     // 定义有序列表
 <ul>    // 定义无序列表
 <p>     // 标签定义段落
 <pre>     // 定义预格式化的文本
 <table>     // 标签定义 HTML 表格
 <tbody>     // 标签表格主体（正文）
 <td>    // 表格中的标准单元格
 <tfoot>     // 定义表格的页脚（脚注或表注）
 <th>    // 定义表头单元格
 <thead>    // 标签定义表格的表头
 <tr>     // 定义表格中的行
```

行内块元素

```html
<button> 
<input>   
<textarea> 
<select> 
<img>
```



#### H5媒体标签



## CSS

#### css属性计算过程

##### 确定声明值

##### 层叠冲突

- ###### 比较源的重要性

  - 浏览器默认样式表为**用户代理样式**。
  - 页面作者编写样式为**页面作者样式**。
  - 页面用户在开发者工具修改的样式为**用户样式**。
  - 权重：页面作者样式 > 用户样式 > 用户代理样式

  ###### 比较优先级

  - 权重：id选择器=100    class选择器=10    标签选择器=1
  
    （!important > 内联样式 > ID > class > 标签）
  
  - 选择权重相加最高的样式
  
  ###### 比较次序
  
  - 后样式覆盖前样式

##### 使用继承

- 继承最近的div样式	

##### 使用默认值

- 剩下样式使用默认值



#### 包含块

##### 初始包含块

##### 非根元素包含块

- 如果元素的 position 是 relative 或 static ，那么包含块由离它**最近的块容器**的边缘建立。

- 如果 position 属性是 fixed，那么包含块由**视口**建立。

- 如果元素使用了 absolute 定位，则包含块由它的最近的 **position 的值不是 static** （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成

- position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：

  - transform 或 perspective 的值不是 none
  - will-change 的值是 transform 或 perspective 
  - filter 的值不是 none 或 will-change 的值是 filter(只在 Firefox 下生效). 
  - contain 的值是 paint (例如: contain: paint;)

  

#### BFC

##### BFC定义

​	块级格式化上下文，形成独立渲染区域，与外界不相干

​	影响：

​	1.水平margin合并

​	2. BFC中元素做外边距和BFC左边缘重叠

##### BFC生成

- 根元素，即HTML标签
- 浮动元素：float值为left、right
- overflow值不为 visible，为 auto、scroll、hidden
- display值为 inline-block、table-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid
- 定位元素：position值为 absolute、fixed

#### 动画	

#### position属性

​	static 正常文档流中布局

​	relative 如不设置top等属性则与static相同，当存在属性则相对自身进行位移并且保留原占位

​	absolute 脱离文档流，相对于最近的定位祖先进行位移

​	fixed 相对于窗口，固定定位，脱离文档流

​	sticky 无top等属性为static，存在属性后。当相对视窗位置小于属性值，fixed。当相对视窗位置大于属性值，relative

#### flex布局

#### 属性继承

##### 	可继承

​		字体属性	文本属性	visibility	列表布局属性	表格布局全局选择器属性

##### 	不可继承

​		display	盒子模型属性	文本属性（vertical-align	text-decoration）	背景属性	定位属性	轮廓属性	页面样式	声音

#### 三种隐藏

​	display:none

​		结构会从DOM树上消失，页面会重排重绘

​	visibility: hidden

​		视觉隐藏，DOM结构不变，不会发生重排。元素占用位置还存在，不会响应事件

​	opacity:0

​		透明度为0，DOM结构不变，元素占用位置还存在，可以继承，可以响应事件

#### 居中的方法

​	1.flex居中:flex属性、margin:auto

​	2.水平居中`margin: 0 auto`

​	3.父relative，子absolute`top:50%,left:50%,transform:translate(-50%,-50%)`

​	4.父relative，子absolute`top0,left0,bottom0,right0,margin:auto`

#### 三个尺寸

##### 	clientWidth

​		元素的用户可见画面宽度，不包含border

##### 	offsetWidth

​		元素全部宽度

##### 	scrollWidth

​		scroll情况下，真实宽度

#### 单位区别

##### 	em、rem 

​		em 相对父元素的倍数		rem 相对根元素的倍数

##### 	vh、vw

​		相对于浏览器，1vh=浏览器1%

## LESS

#### 	概括

​		CSS预处理器，实现动态样式，增加样式复用性，可编程思想。可以运行在浏览器和node

#### 	变量

#### 	混合

​		把另一个选择器的名字放在这个样式里面，这个样式会具有放入的选择器的样式。带参数可实现函数式定义样式。（类似函数调用，提高样式复用性）

#### 	匹配模式

```less
.triangle(top,@w:100px,@c:red){ //根据第一个参数进行匹配
    width: 0;
    height: 0;
    border-width: @w;
    border-color: transparent transparent @c transparent;
    border-style: dashed dashed solid dashed;
}
.triangle(@_, @w:100px,@c:red){ //共用参数定义，第一个参数一定为@_
    width: 0;
    height: 0;
    overflow: hidden;
}
.box{
    .triangle(top)
}
```

#### 	嵌套

#### 	运算

 

































## JS

#### 预编译 

​	变量声明和函数声明的提升

​	作用域内变量未声明就赋值，成为全局变量，存在window

​	预编译发生在函数执行的前一刻

##### 	步骤  

​		1.创建AO对象（执行上下文对象）（方法内）

​			创建GO对象（全局） 

​		2.找形参和变量声明，将变量和形参名作为AO属性名，值为undefined

​		3.将实参值和形参统一(浅拷贝)

​		4.在函数体内找函数声明，值赋予函数体

```javascript
例子1：
function fn (a){
    console.log(a)
    var a = 123
    console.log(a)
    function a(){}
    console.log(a)
    var b = function(){}
    console.log(b)
    function d(){}
}
fn(1)

1.AO{
    
}
2.AO{
    a:undefined   //var a
    b:undefined   //var b
}
3.AO{
    a:1   //实参a=1
    b:undefined   //var b
}
4.AO{
    a:function a(){}   //function a(){}
    b:undefined   //var b
    d:function d(){}  //function d(){} 
}
5.AO{
    a:123   //a=123
    b:undefined   //var b
    d:function d(){}  //function a(){} 
}
6.AO{
    a:123   //a=123
    b:function(){}   //function(){}
    d:function d(){}  //function d(){} 
}
7.AO{
    a:123   //a=123
    b:function(){}   //function(){}
    d:function d(){}  //function d(){} 
}
-----------------------------------------
例二：
console.log(test)
function test(test){
    console.log(test)
    var test = 234
    console.log(test)
    function test(){}
}
test(1)
var test = 123
// function test(){...}  function test(){}  234

1.GO{
    test:function(){  //var test -> function test(){...}
        ...
    }
}
2.AO{
    test:function(){} //var test -> a= 1 -> function test(){}
}
-------------------------------------------
例三：
function Foo(){
    getName = function(){
        console.log(1);
    }
    return this
}
Foo.getName = function(){
    console.log(2);
}
Foo.prototype.getName = function(){
    console.log(3);
}
var getName = function(){
    console.log(4);
}
function getName(){
    console.log(5);
}
Foo.getName()//2 调用Foo.getName，查找Foo.getName = function(){}
getName()//4 全局调用 查找var getName = function(){}
Foo().getName()//1 调用Foo内的getName 返回this-->window getName为定义就赋值变成全局方法，执行getName = function(){}
getName()//1    因为上一句执行getName = function(){}
new Foo.getName() //2  Foo是函数，new函数等于执行该函数
new Foo().getName() //3 new Foo()返回实例对象，向原型链查找getName，在protrype有getName
new new Foo().getName() //3 首先new Foo().getName()是函数 在new 这个函数等于执行这个函数
```



#### 作用域链

##### 	定义

​		[[scope]]中存储的执行上下文对象的集合，呈链式结构。

​		[[scope]]：作用域，存储了执行上下文的集合（存储多个AO和GO）

##### 	产生

​		1. 作用域链可以理解为栈，查询变量都从栈顶出发，每次产生AO都放栈顶

​        2. 函数定义不产生自己的AO，只继承上层函数的AO和GO。当函数被执行，产生自己的AO并入栈。（头层函数被定义时产生GO）

​	    3. 函数执行完毕，自己的AO出栈销毁，释放内存

```javascript
function a(){
    function b(){
        var b = 234
    }
    var a = 123
    b()
}
var global = 100
a()

//a definde: a.[[scope]] --> 0 : GO:{}
//a doing: a.[[scope]] --> 0 : AO:{}
//                         1 : GO:{}
//b definde: a.[[scope]][0] --> b.[[scope]] --> 0 : AO:{}(a.[[scope]]的AO)
//                                       --> 1 : GO:{}(a.[[scope]]的GO)
//b doing: a.[[scope]][0] --> b.[[scope]] --> 0 : AO:{} (b自己的AO)
//                                     --> 1 : AO:{}(a.[[scope]]的AO)
//                                     --> 2 : GO:{}(a.[[scope]]的GO)

```



#### 闭包

##### 	概述

​		内部函数被保存到外部，外部可以访问到内部函数作用域 

```javascript
function a(){
    function b(){
        a++
    }
    var a = 1
    return b
}
var demo = a()
demo()
```

​		a()定义和执行产生GO和aAO，b()被定义后携带GO和aAO，return b导致外部能得到GO和aAO，所以外部可以访问a()的变量

##### 	场景

​		1.实现公有变量（无需定义全局变量，实现全局变量效果）（埋点计数器）

```javascript
function add (){
    var count=0
    function add2(){
        console.log(++count)
    }
    return add2
}
var myAdd = add()
myAdd()//可以循环执行
//因为add2给到全局，使得add()的AO也给到全局，所以变量count不会被垃圾回收，从而实现累加
```

​		2.柯里化（将多参数函数变成单参数函数）

```javascript
// 原函数 用来检验文本是否符合规范
// reg 传入的正则表达式  txt 需要被检测的文本
function check(reg,txt){
	return reg.test(txt)
}
console.log(check(电话号码的正则,13923456789));
console.log(check(邮箱的正则,youxiang@163.com));

// 现如今
function nowCheck(reg){
	return function(txt){
		return reg.test(txt)
	}
}
var isPhone = nowCheck(电话号码的正则)
console.log(isPhone('13923456789'))
var isEmail = nowCheck(邮箱的正则)
console.log(isEmail('youxiang@163.com'))
```

​		3.实现封装，属性私有化

​		4.模块化开发，防止污染全局变量

##### 	缺点

​		因为变量存活周期变长，当内部函数执行后变量不会被垃圾回收机制回收，导致存在内存泄漏的风险

​		导致原有作用域链不释放，造成内存泄漏（可用内存变少）

##### IIFE（立即执行函数）

​		**函数表达式才可以执行，通过数学符号（）将函数声明变成函数表达式，加上（）执行符号，从而执行。**

​		执行完立马销毁

​		w3c标准:`(function (){}())`

​	IIFE解决问题

```javascript
function test(){
    var arr=[]
    for(var i = 0;i<10;i++){
        (function(j){
            arr[j] = function(){
                console.log(j)
            }
        }(i))
    }
    return arr
}
var my = test()
for(var o = 0;o<10;o++){
    my[o]()
}
```



#### 原型链

##### 	原型

​		**构造函数的一个属性，作为构造函数制造出的对象的公共祖先。通过构造函数产生的对象，可以继承这个属性的属性和方法。**

​		constructor：`构造函数=new Person()`，可以通过原型修改构造函数 `Person.prototype = { constructor : Car }`

##### 	原型链

​		`构造函数.prototype = 实例对象.__proto__（指向**.prototype）`

​		`*.prototype.__proto__ = Object.prototype`

​		Function:

​			`Function.实例化 = Function`

​			`Function.prototype = Function.__proto__`

​		Object:

​			`Object.实例化 = Object.prototype`

​			`Object.prototype.__proto__ = null`

##### 	特例：所有对象最终都继承`Object.prototype` -----错误

​		`Object.create(原型)` 当`let obj = Object.create(null)`,该对象原型为null		![img](https://img-blog.csdn.net/20170503152146141?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3BpY3lCb2lsZWRGaXNo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

​		

#### call/apply

​	作用：改变this指向

​	区别：参数形式不同

​		call 需要把实参按形参个数传进去

​		apply 需要传一个arguments

##### 		call

```javascript
function Person(name, age, sex){
    this.name = name
    this.age = age
    this.sex = sex
}
function Student(name, age, sex, tel, grade){
    Person.call(this, name, age, sex)
    this.tel = tel 
    this.grade = grade
}
let student = new Student('benny',123,'male',129,2017)
```

##### 		apply

```javascript
function Person(name, age, sex){
    this.name = name
    this.age = age
    this.sex = sex
}
function Student(name, age, sex, tel, grade){
    Person.apply(this, [name, age, sex])
    this.tel = tel 
    this.grade = grade
}
let student = new Student('benny',123,'male',129,2017)
```

​		

#### 类

##### 	定义：对象的模板

##### 	封装：存储属性的同时，要保护数据安全

​		确保数据安全：

​			1.数据私有化 使用 **#** 定义属性

​			2.提供getter和setter 暴露属性

​				一 、控制数据读写权限

​				二 、可以验证修改值

```javascript
class Person{
    #address = 'abc'
    constructor(name){
        this.name = name
    }
    sayHello(){
        consolelog(this.#address)
    }
}
const p1 = new Person('666')
//当属性加上# 外界只能通过内部函数读取该属性，p1.address访问无效
//私有化属性需要先声明再初始话
```

##### 	多态：函数参数不检查类型，将不同对象作为参数

##### 	继承



#### This指向

##### 	绑定规则(优先级)

​	1  默认绑定规则 ：`this===window`

```javascript
function test(){
    console.log(this)
}
test() //window
```

​	2 隐式绑定规则： 谁执行函数就 指向谁（隐式丢失和参数赋值都会改变这个规则）

```javascript
//隐式丢失 
var a = 0
function foo(){
    console.log(this)
}
var obj = {
    a:2,
    foo:foo
}
obj.foo() //obj
var bar = obj.foo
var bar = foo
bar() //window
foo() //window
//-------------------------------------
//参数赋值
var a = 0
function foo(){
    console.log(this)
}
function bar(fn){
    fn()
}
var obj = {
    a:2,
    foo:foo
}
bar(obj.foo) //window
```

​	3 显式绑定： call  apply   bind  主动改变this指向，参数为新的this

```javascript
//隐式丢失 
var a = 0
function foo(){
    console.log(this)
}
var obj = {
    a:2,
    foo:foo
}
var bar = obj.foo
obj.foo() //obj
bar.call(obj) //obj
bar.apply(obj) //obj
bar.bind(obj)() //obj
```

​	4. new绑定(new 改变 this 指向)

```javascript
function Person(){
    var this={}
    this.a=1
    return this
}
var person = new Person() // this = person
```

​	优先级例子

```javascript
function foo(b){
    this.a = b 
}
var obj1 = {}
var bar = foo.bind（obj1)
bar(2)
console..log(obj1.a) //2
var baz = new bar(3)
console..log(obj1.a) //2 new改变指向到baz，变成baz有a属性
console..log(baz.a) //3 

//new > bind=apply=call
```

##### 	箭头函数This（内部函数获取外部函数this）

​		箭头函数This为父级作用域This（不存在this）

##### 	箭头函数This绑定规则

​		1.默认绑定规则（独立调用对箭头函数）无效

```javascript
function foo(){
    console.log(this)
    var test = () =>{
    	console.log(this)
	}
    return test
}
var obj1 = {
    a:1,
    foo:foo
}
var obj2 = {
    a:2,
    foo:foo
}
obj1.foo()() //window

```

​		2.显示绑定无效

```javascript
function foo(){
    console.log(this)
    var test = () =>{
    	console.log(this)
	}
    return test
}
var obj1 = {
    a:1,
    foo:foo
}
var obj2 = {
    a:2,
    foo:foo
}
var bar = foo().call(obj2) //window

```

​		3.隐式绑定无效

```javascript
var obj1 = {
    a:1,
    foo:()=>{
        console.log(this)
    }
}
obj1.foo() //window
```

​		4. new 不能实例箭头函数

```javascript
var foo = ()=>{
    console.log(this)
}
new foo() //报错 无constructor
```

##### 	例子

```javascript
var name = 'window'
var obj1  = {
    name:'1',
    fn1:function(){
        console.log(this.name)
    },
    fn2:()=>console.log(this.name),
    fn3:function(){
        return function (){
            console.log(this.name)
        }
    },
    fn4:function(){
        return () => console.log(this.name)
    }
}
var obj2 ={
    name:'2'
}

obj1.fn1()  //1  obj1调用
obj1.fn1.call(obj2)  //2  call改变this至obj2
 
obj1.fn2() //window  箭头函数找父作用域this
obj1.fn2.call(obj2) //window  箭头函数不遵守主动绑定

obj1.fn3()()  //window  obj1.fn3()得到函数，再()变成自调用，为window
obj1.fn3().call(obj2) //2  显示绑定，改变this为obj2
obj1.fn3.call(obj2)()  //window 显示绑定后自调用，为window

obj1.fn4()()  //1  fn4为箭头函数父作用域，箭头函数this为fn4的this。因为是obj1调用fn4，所以箭头函数this为obj1
obj1.fn4().call(obj2) //1 obj1.fn4()-->()=>{}  所以变成 ()=>{}.call(obj2) 箭头函数不接受显示绑定，所以同上
obj1.fn4.call(obj2)() //2 改变了fn4的this指向为obj2，然后再执行箭头函数，此时箭头函数this为obj2
```



#### 迭代器、生成器

##### 	迭代器定义

​		从目标源依次逐个抽取的方式来提取数据

​		目标源：1.有序的 2.连续的		

​		原生可迭代对象：Array Map Set String TypedArray arguments NodeList

##### 	重写迭代器，对对象进行迭代输出

```javascript
var obj = {
    a: 1,
    b: 2,
    c: 3,
    [Symbol.iterator]() {
        var index = 0
        let map = new Map()
        map.set('a', 1)
        map.set('b', 2)
        map.set('c',3)
        return {
            next() {
                var mapEntries = [...map.entries()]
                if(map.size>index){
                    return {
                        value:mapEntries[index++],done:false
                    }
                }
                return{
                    value:undefined,done:true
                }
            }
        }
    }
}
for(let i of obj){
    console.log(i);
}
```

##### 	生成器定义

​		一种异步解决方案，使用yield来形成“断点”，需要使用next()来控制执行

​		遇到yield便暂停执行，讲后面的值作为返回对象的value

```javascript
function * foo(){
    yield 'hhh'
    console.log(111);
    yield
}
let test = foo()
console.log(test.next().value); // hhh
test.next() // 111
```

##### 	使用生成器,重写迭代器进行迭代对象

```javascript
var obj = {
    a: 1,
    b: 2,
    c: 3,
    [Symbol.iterator]:function*() {
        var index = 0
        let map = new Map()
        map.set('a', 1)
        map.set('b', 2)
        map.set('c',3)       
        var mapEntries = [...map.entries()]
        while(index < mapEntries.length){
            yield mapEntries[index++]
        }
    }
}
for(let i of obj){
    console.log(i);
}
```



#### Promise

##### 	解释

​		一种承诺，类比成去买麦当劳，下单后返回取餐码就是promise，有餐给你就是resolve()，没有餐给你就是reject()

##### 	三个状态

​		pending 待定                   fulfilled 已兑现                rejected 已拒绝

##### 	thenable对象

```javascript
let obj = {
    then(resolve,reject){
        resolve(11)
    }
}
let p1 = Promise.resolve(obj)
p1.then((data)=>{
    console.log(data) //11
})
//传入thenable对象，如果promise是fulfilled状态，就会执行对象中then中的回调
//如果是rejected状态，则不会执行then中回调
```

##### 	链式调用

```javascript
let p1 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve(10)
    },1000)
})
p1.then(res=>{console.log(res) return res+1}) //10
p1.then(res=>{console.log(res) return res+1}) //10
p1.then(res=>{console.log(res) return res+1}) //10

p1.then(res=>{console.log(res) return res+1}) //10
	.then(res=>{console.log(res) return res+1}) //11
	.then(res=>{console.log(res) return res+1}) //12

p1.then(res => console.log(res))
	.then()//返回空promise
	.then()//返回空promise
	.then(res => console.log(res))
//10 undefined
```

##### 	状态依赖

```javascript
let p1 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        reject('err')
    },3000)
})
let p2 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve(p1)
    },1000)
})
p2.then(res => console.log(res))
	.catch(err => console.log(err))
//err
//先执行p2的resolve，但是没有得到p1，需要等待p1完成。p1返回reject，p2的resolve依赖于p1状态，所以p2不执行resolve,执行catch
```

##### 	`Promise.all() `

​		如果全是resolve，then输出全部fufilled结果

​		如果存在reject，catch输出第一个reject结果

```javascript
let p1 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve(10)
    },1000)
})
let p2 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve(20)
    },2000)
})
let p3 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve(30)
    },3000)
})
let p4 = Promise.all([p1,p2,p3])
p4.then(res=>console.log(res))
	.catch(res => console.log(res))
//[10,20,30]
```

##### 	`Promise.race()`

​		谁最早返回结果就获取谁

```javascript
let p1 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve(10)
    },1000)
})
let p2 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve(20)
    },2000)
})
let p3 = Promise.race([p1,p2])
p4.then(res=>console.log(res))
	.catch(res => console.log(res))
//10
```

##### 	Promise A+

​		1.状态：pending fulfilled rejected

​		2.Then方法 `promise.then((onFulfilled,onRejected)=>{})`

​		3.Promise解决过程 有关两个方法的参数问题



#### async/await

##### 	个人理解

​		promise的语法糖，目的是解决.then()的链式调用

##### 	特点

​		1 async 声明的异步函数，默认返回Promise

​		2 async 声明的异步函数可以使用await调用其他异步函数

​		3 await 后接需要调用的异步函数。调用await，会等待Promise执行出结果后将结果返回，通过变量接收

​		4 await 只是改变异步函数的调用方式（ 取代.then() ），但不会将异步函数变为同步函数（使用await是想让异步函数的调用方式变成同步的调用方式）

​		5 await 使用场景： ① async 声明的函数内  	② 需要try catch包含 	③ 在模块中的最外层作用域中，无需async

```javascript
async function fn1(){
    return 10 
}
async function fn2(num){
    return 10 + num 
}
async function fn3(num){
    return 10 + num 
}
async function fn4(num){
    return 10 + num 
}

async function fn5(){
    try{
        let result = await fn1
        result = await fn2(result)
        result = await fn3(result)
        result = await fn4(result)
        console.log(result)
    }catch(e){
        console.log(e)
    }
}
```



#### 深拷贝浅拷贝

##### 	浅拷贝---只复制对象的指针

​		对象复制通常是浅拷贝

​		方法：`Object.assign() Array.prototype.slice() Array.prototype.concat() 拓展运算符`

##### 	深拷贝---所有数据复制，指针变化，开辟新的内存空间

​		性能差

​		方法：`JSON.parse() JSON.stringify() 手写deepClone递归函数`

```javascript
function deepCopy(obj){
    if (!obj || typeof obj !== "object") return obj;

    var retObj = {};

    for (var attr in obj){
        var type = obj[attr];

        switch(true){
            case (type instanceof Date):
                var _d = new Date();
                _d.setDate(type.getDate())
                retObj[attr]= _d;
                break;

            case (type instanceof Function):
                retObj[attr]= obj[attr];
                break;

            case (type instanceof Array):
                var _a =[];
                for (var e of type){
                    //_a.push(e);
                    _a.push(deepCopy(e));
                }
                retObj[attr]= _a;
                break;

            case (type instanceof Object):
                var _o ={};
                for (var e in type){
                    //_o[e] = type[e];
                    _o[e] = deepCopy(type[e]);
                }
                retObj[attr]= _o;
                break;

            default:
                retObj[attr]= obj[attr];
        }
    }
    return retObj;
}
```



#### 高阶函数

​	参数是函数或者返回值是函数的函数

​	`fliter 、 map、 sort、 some、 every、 reduce`



#### 防抖和节流

##### 	防抖

​		通过setTimeout的方式，在一定的时间内间隔，将多次触发变成一次触发

```javascript
let btn = document.querySelector('button')
btn.addEventListener('click', debounce(submit, 2000))

function submit() {
    console.log(arguments);
}

function debounce(fn, time) {
    let timer = null
    return function () {
        if (!timer) { //判断是否为第一次执行
            fn(arguments)
            timer = setTimeout(() => {}, time)
        } else {
            if (timer) { //每次点击查看是否有定时器，有就清除，然后重新开启定时器
                clearTimeout(timer)
            }
            timer = setTimeout(() => {
                fn(arguments)
            }, time)
        }
    }
}
```

##### 	节流

​		减少一段时间的触发频率

```javascript
let btn = document.querySelector('button')
btn.addEventListener('click', throttle(submit, 2000))

function submit(e) {
    console.log(e,this);
}

function throttle(fn, time) {
    let begin = 0
    return function(){
        let now = new Date().getTime()
        if(now - begin > time){
            fn(arguments)
            begin = now
        }
    }
}
```



#### 数组

```javascript
//改变原数组
arr.push() //队尾加元素
arr.pop()  //队尾删元素
arr.shift() //队头删元素
arr.unshift() //队头加元素
arr.reserve() //翻转数组
arr.sort() //数组排序
arr.splice() //分割数组，删除和替换元素 返回被分割的元素
//不改变原数组
arr.concat() //合并数组
arr.slice() //截取一部分数组
arr.join()	//将数组变为字符串
arr.indexOf() //从队头查找第一个符合规则的元素的位置
arr.lastindexOf() //从队尾查找第一个符合条件的元素的位置
//ES6
arr.forEach(() => {}) //遍历数组
arr.some(() => {}) //判断数组中是否有符合条件的元素
arr.every(() => {}) //判断数组所有元素是否符合条件
arr.fliter(() => {}) //按照条件过滤数组
arr.map(() => {}) //将数组变成映射
arr.find(() => {}) //获取符合条件的一个元素的位置
arr.reduce((pre,value,index,arr) => {
    //第一次:pre=arr[0],value=arr[1] 
    //如果有初始值: 第一次：pre=初始值，value=arr[0]
    //其次: pre = 内部函数返回值, value=下一个元素
},初始值) 
```

​	

#### Ajax

##### 概述

​	异步的JavaScript和XML

##### ajax优缺点

​	优点： 1无需刷新页面就能和服务器通信		2允许根据用户事件来更新页面数据

​	缺点： 1没有历史记录无法回退		2存在跨域问题		3seo不友好

##### ajax实现

​	1 基于XMLHttpRequest对象，建立该对象实例`const xhr = new XMLHttpRequest()`

​	2 建立连接`xhr.open(method,url,async)`，async 默认值为true

​	3 发送请求 `xhr.send()`

​		get请求：将参数写入url，send()方法内无需传参

​		post请求：需要设置请求头`xhr.setRequestHeder("Content-Type","application/x-www-form-urlencoded;charset=UTF-8");`，再使用send()发送数据

​	4 响应处理

​		状态值：AJAX所经历过的几种状态，无论访问是否成功都将响应的步骤，可以理解成为AJAX运行步骤

```
0：初始化，XMLHttpRequest对象还没有完成初始化
1：载入，XMLHttpRequest对象开始发送请求
2：载入完成，XMLHttpRequest对象的请求发送完成
3：解析，XMLHttpRequest对象开始读取服务器的响应
4：完成，XMLHttpRequest对象读取服务器响应结束
```

​		状态码：无论AJAX访问是否成功，由HTTP协议根据所提交的信息，服务器所返回的HTTP头信息代码

​						200交易成功	404没有发现文件、查询或URl

​	5 停止当前请求`xhr.abort()`

```js
xhr.onreadystatechange=function(){
    // readyState == 4说明请求已完成
    if(xhr.readyState==4){
        if(xhr.status==200 || xhr.status==304){
            console.log(xhr.responseText);
        }
    }
}
```



##### 跨域解决		

​	1动态创建script标签

​	2 设置请求头origin

​	3 反向代理

​	4 window+iframe



### 模块化

##### 	commonJS和ES6区别

​		1.commonJS是深拷贝实现，ES6是浅拷贝获取数据的引用

​		2.commonJS是在运行时加载。ES6是在编译时加载（浏览器无法进行编译，需要通过webpack ）

​		



































## VUE

#### MVVM框架

由View ViewModel Model组成的框架。view(页面)	ViewModel(页面处理逻辑)	Model(页面服务器)



#### Object.defineProperty() 

传入一个对象，将对象的属性设置为对象，并返回该对象

```javascript
function dP(){
    let _obj={}
    Object.defineProperty(_obj,'a',{
        value:'111',//数据描述符
        writable:true,  //允许被修改
        enumerable:true,  //允许被枚举（遍历，迭代）
        configurable:true  //允许被删除
    })
    return _obj
}
let obj = dP()
console.log(obj.a) //111

//数据存储符
function dP(){
    let _obj={}
    let a = 1
    Object.defineProperty(_obj,{
        a:{
            //数据存储描述符
            get(){
                return a
            }
            set(value){
                a=value
            }
        }
    })
    return _obj
}
let obj = dP()
console.log(obj.a) //111

//数据描述符不能和数据存储符一起使用
```



#### 数据双向绑定v-model

##### 	双向绑定，单项数据流

​		单项数据流：数据向下，方法向上。

##### 原理

​		一、视图变化更新数据：通过事件监听的方式实现对视图变化的监测

​		二、数据变化更新视图：

​			1 数据观察者Observer实现对数据进行监测：让数据的读写都在自己的监视下进行，在init vm时创建

​			2 数据订阅者Watcher：数据变化后通知watcher，watcher去重新允许render函数更新页面

​			3 Dep纽带：Observer通知Watcher通过Dep进行传输

##### 	总结

​		当view改变，数据改变。当数据改变，view改变。

​		语法糖，包含两个操作：

​			1 v-bind绑定一个value属性

​			2 v-on给当前元素绑定input事件

```vue
<input type="text" :value = 'message' @input="message = $event.target.value">
<input type="text" v-model = 'messgae'>
```



#### 响应式原理

##### 基本概念

​	数据劫持：set() get()方法设置关卡，当修改或者读取数据时，进行数据劫持完成起函数内逻辑

​	依赖收集：getter方法内有个Dep.target参数，target就是watch实例。在beforeMount和mounted之间，会实例化Watch实例，Watch的constructor将实例保存到target上。当getter被调用，dep.denpend()把watch实例保存，就是依赖收集



##### 	简略版

​	1.Vue遍历每个传入data的传统对象的属性，使用Object.defineProperty()把这些属性全部变为getter、setter

​	2.render函数使用这些响应式data形成虚拟DOM树

​	3.render函数使用到响应式数据后，数据的getter方法会进行记录，render使用了这个data，并被watcher进行观察（依赖收集（使用数据的地方），一个watch实例）。当修改响应式数据，数据的setter会通知观察者watcher，于是观察者会让render函数再次使用当前响应式数据形成虚拟DOM树。 

​	<img src="https://v2.cn.vuejs.org/images/data.png" alt="data" style="zoom: 33%;" />

##### 详细版

![img](http://cdn.yinhengli.com/image-20200804221209264.png)

1.`new Vue`阶段会生成一个`Observer`对象，这个对象会对data数据进行遍历，使用`Object.defineProperty()`将所有数据变成响应式，包含`set() get()`方法

2.然后`Observer`对象会创建`Dep`对象进行依赖管理。

3.在`beforeMounted`阶段，会创建`Watcher`对象，并且调用`render`方法生成虚拟DOM树

4.当读取数据时会调用`get()`，于是将`watcher`放入`Dep`中进行依赖收集，记录是谁使用了该数据

5.当更新数据会调用`set()`方法，通过`Dep.notify()`进行派发更新,通知`watcher`

6.`watcher`会重新执行`render`方法进行虚拟DOM的更新

7.因为每个函数都会有一个`watcher`，所有会存在一个`Scheduler`调度器进行`watcher`的调度。`Scheduler`通过将`watcher`放入队列中，使用`nextTick`方法将他们放入微队列变成异步函数，实现资源的节省。如果是第一次执行该`watcher`就会立即执行。



#### diff算法

##### 	概述

​		比较新旧两个虚拟DOM不同，进行页面更新。

##### 	过程

​		1 `Dep.notify()`通知订阅者调用`petch(oldvnode，newvnode)`方法进行比较

​		 	1.1 不是同类标签直接替换

​			 1.2 是同类标签则调用`petchVnode()`方法进行比较

​					1.2.1 相等则return

​					1.2.2 不相等

​						1.2.2.1 old和new都有文本节点：新文本代替旧文本

​						1.2.2.2 old无子节点，new有子节点：增加新子节点

​						1.2.2.3 old有子节点，new无子节点：删除旧子节点

​						1.2.2.4 old，new都有子节点：调用`updateChildren()`比较所有子节点	

​							一、同级比对

​							二、新旧指针法 （`oldS和newS oldS和newE oldE和newS oldE和newE`）

​	

#### vuex

##### 	概述

​		状态管理仓库

##### 	作用

​	不同组件数据**保持同步**

​	数据的修改都是**可追踪**

##### 	五个对象

​		state 数据存储对象

​		mutations 修改state方法对象

​		actions 异步函数对象

​		getter 读取state方法对象 

​		modules 模块化仓库存储对象

​			state要变成函数，将数据返回出去。目的是形成单独作用域。

函数式调用仓库属性

```javascript
...mapState({
    'valueName' : state => state.moduleName.valueName
})
```



##### 命名空间

​		防止不同模块中的方法名冲突，让每一个模块形成独立空间

​		组件中调用各个对象方法有改变：

​			1.state

​			`...mapState('moduleName',['stateValueName'])`

​			`this.$store.state.moduleName.valueName`

​			2.mutations

​			`...mapMutations(['moduleName/mutationsFnName'])`

​			`this.$store.commit('moduleNmae/mutationsFnName',value)`

​			3.actions

​			`...mapActions(['moduleName/actionsFnName'])`

​			`this.$store.dispatch('moduleName/actionsFnName',value)`

​			4.getter

​			`...mapGetters(['moduleName/getterFnName])`

​			`this.$store.getters['moduleName/getterFnName']`

##### 	注意

​		组件中v-model不能直接修改state中数据，需要进行响应式修改。

```js
message: {
    get () {
        return this.$store.state.message
    },
        set (value) {
            this.$store.commit('updateMessage', value)
        }
}
```



#### vue-router

##### 	路由跳转方式

```vue
<router-link :to="/path"></router-link>

this.$router.push({
	path:'/path',
	params:{
		id:100
	},
	query:{
		id:100
	}
})
```

##### 	传参	

​		query：需要在路由配置里面定义参数 `path:'/path?id'`

​		params: 路由跳转只能通过name，无需在路径定义参数

##### 	路由守卫

​		前置路由 后置路由 参数（from，to，next）

#### vue-axios	

##### 		axios和fetch区别

​		1.axios(option) option放入所有数据	fetch(url,option) url为请求地址，option为其他配置

​		2.axios有自带的请求超时服务

​		3.axios能够进行http拦截，请求拦截器和响应拦截器

​		4.axios基于XmlHttpRequest，fetch属于全新

​		5.axios兼容性更好，支持自动转json，更加安全

##### 配置axios

```js
let api = axios.create({
    baseUrl:'/api',
    timeout:1000
})
api.interceptors.request.use(config=>{
    ...
},err=>{
    ...
})
api.interceptors.respose.use(res=>{
    ...
},err=>{
    ...
})
```

​		





#### $nextTick()=>{}

​	在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM

​	场景

​		在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。

​		在数据变化后要执行的某个操作

​		mounted 不会承诺所有的子组件也都一起被挂载。

#### 组件通信

​	1.pros

​	2.自定义事件

​	3.全局事件总线

​	4.vuex

​	5.slot插槽

​	6.消息订阅和发布

#### 生命周期

​	![20201227152934734.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3723c888d3524c399d3f90c54009efd5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

#### 插槽

##### 	默认插槽

```vue
<Test>
    <h1>Test</h1>
</Test>

//Test.vue
<div>
    <slot></slot>
</div>
--->
<div>
    <h1>Test</h1>
</div>
```

##### 	具名插槽

​		通过`v-slot`：进行具体插槽绑定，可以简写为`#`

```vue
<Test>
    <template #one>
    	<h1>Test1</h1>
    </template>
	<template #two>
    	<h1>Test2</h1>
    </template>
    <template #three>
    	<h1>Test3</h1>
    </template>
    <template #four>
    	<h1>Test4</h1>
    </template>
</Test>

//Test.vue
<div>
    <slot name="one"></slot>
    <slot name="two"></slot>
    <slot name="three"></slot>
    <slot name="four"></slot>
</div>
-->
<div>
    <h1>Test1</h1>
    <h1>Test2</h1>
    <h1>Test3</h1>
    <h1>Test4</h1>
</div>
```

##### 	作用域插槽

​		解决父子组件作用域不互连

​		`name`为slot自带属性，不会将其进行传值

```vue
<Test>
    <template #one="scope">
    	<h1>Test1</h1>
		<h2>{{scope.msg}}</h2>
    </template>
	<template #two="scope">
    	<h1>Test2</h1>
		<h2>{{scope.msg}}</h2>
    </template>
</Test>

//Test.vue
<div>
    <slot name="one" msg="test 1"></slot>
    <slot name="two" msg="test 2"></slot>
</div>
--->
<div>
    <h1>Test1</h1>
    <h2>test 1</h2>
    <h1>Test2</h1>
    <h2>test 2</h2>
</div>
```

#### 混入

理解为组件中的组件，提高代码复用性

```js
export default myMixin = {
    data(){
        return:{
            
        }
    },
    methods:{},
    computed:{},
    created(){},
    mounted(){},
}
```

```vue

```



#### 插件



#### 过渡动画

#### Vue2 Vue3区别



## 计算机网络

#### OSI七层模型

​	物理层 链路层 网络层 传输层 会话层 表示层 应用层

​	物理层：端到端，比特传输

​	链路层：帧传输

​	网络层：IP协议，数据报

​	传输层：UDP TCP 报文段

​	会话层：提供数据交换的定界和同步功能，包括建立检查点和回复方案

​	表示层：数据压缩，加密，描述

​	应用层：HTTP SMTP FTP 报文

#### 	DNS(域名服务器)

​		作用：域名和对应的IP转换的服务器

​		特征：DNS保存了一张域名和对应的IP地址的表

​					一个域名对应一个IP，一个IP可对应多个域名

​		查询：本地服务器 -> 根服务器 -> .com域服务器 ->（本地服务器）-> url域服务器 -> 本地服务器（缓存）-> 浏览器

#### 	IP（互联网协议地址）

​		作用：分配给用户上网使用的互联网协议

​		IPV6优势：

​			1路由表更小 2自动配置 3安全性高 4空间更大（8组（126位））

#### 	端口号（服务器具体服务位置）

​		每个端口对应一个服务器的一个具体业务

​	举例：ip（广东省东莞市莞城街道） 域名（广东省东莞市莞城人民公园） 端口（公园海盗船入口）

#### 	TCP（传输控制协议）

​		特点：面向可靠连接	

​		优缺点：缺点（速度慢、效率低、占用资源、易被攻击）优点（稳定、重传机制、拥塞控制）

​		TCP/IP协议组：提供点对点的连接机制，制定了数据的封装、定址、传输、路由、数据接收的标准

#### 	UDP（用户数据报协议）

​		特点：面向无连接（不可靠，无状态）

​		优缺点：优点（安全、快速） 缺点（不可靠，丢包，不稳定）

​		只要源地址、端口号确定就能直接发送报文，但不保证完整

#### TCP三次握手和四次挥手

##### 	序号和确认号

​		序号seq：通信过程中某个方向上的字节流的每个字节号

​		确认号ack：对上一次seq序号做出的确认号，用来响应报文段，给收到的报文段seq加1

##### 	标志位

​		**SYN：同步标志位，用于建立会话连接，同步序列号；**

​		**ACK： 确认标志位，对已接收的数据包进行确认；**

​		**FIN： 完成标志位，表示我已经没有数据要发送了，即将关闭连接；**

​		PSH：推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队；

​		RST：重置标志位，用于连接复位、拒绝错误和非法的数据包；

​		URG：紧急标志位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理；

##### 	三次握手

​		四个状态：LISTEN（侦听TCP端口的连接请求）	SYN-SENT：发送连接请求后等待匹配的连接请求

​					  SYN-RECEIVED（收到请求，发送请求等待确认）	ESTABLISHED（建立连接）

​		过程：

​			**第一次握手**：客户端将TCP报文”标志位SYN设置为1“，再随机产生一个序号值seq=j，保存在TCP首部的序列号（Sequence Number）字段，指明客户端打算连接服务器端的端口，并将数据包发给服务器端，客户端随之进入`SYN_SENT`状态，等待服务器端的确认信息。

​			**第二次握手**：服务器端收到客户端发来的数据包后，由”标志位SYN=1“得知，客户端要请求建立连接，服务器端将TCP报文的”标志位SYN“和和”ACK“都设置为1，”ack=j+1“，然后随机产生一个序号值"seq=k",并将该数据包发给客户端确认建立连接，服务器端进入`SYN_RCVD`状态

​			**第三次握手**：客户端收到后检查”ack是否为j+1，ACK是否1”，如果检查正确，则将ACK设置为1，ack设置为k+1，发送给服务器端，服务器端检查ACK是否为1，ack是否为k+1，如果检查正确则成功建立连接，客户端和服务端都进入“ESTABLISHED”状态，完成三次握手，开始传输数据。

<img src="https://pic4.zhimg.com/80/v2-70c372f89d636cc55d8ce70127cde09b_720w.webp" alt="img" style="zoom: 80%;" />

##### 		四次挥手

​		六个状态：FIN-WAIT-1（等待远端TCP连接终止请求）	TIN-WAIT-2（等待远端TCP连接终止请求） 

​						  CLOSE-WAIT（等待本地用户的连接终止请求）	LAST-ACK（等待先前发送给远端TCP 的连接终止请求的确认） 	    

​						  TIME-WAIT（等待足够的时间确保TCP终止）	CLOSED（连接终止）

​		过程：

​			**第一次挥手**：客户端发送断开TCP连接请求，报文中包含随机生成的序列号seq=x，FIN=1，进入**FIN-WAIT-1**状态

​			**第二次挥手**：服务端回复断开请求表示同意断开，报文中包含随机生成的序列号seq=y，ACK=1，ack=x+1，状态进入**CLOSE-WAIT**状态，客户端进入**FIN-WAIT-2**状态

​			**第三次挥手**：当没有数据后，服务端发送连接断开请求表面没有其他数据可以断开连接，报文中包含FIN=1，ACK=1，随机生成的seq=z，ack=x+1，进入**LAST-ACK**状态

​			**第四次挥手**：客户端确认断开请求，报文中包含ACK=1，seq=x+1，ack=z+1，进入**TIME-WAIT**状态。服务端收到确认后进入**CLOSED**状态。客户端在等待2MSL后进入**CLOSED**状态

<img src="https://pic3.zhimg.com/80/v2-fb8efc0a5fbe53d2cb8e4919d3fa4a8e_720w.webp" alt="img" style="zoom: 80%;" />

##### 		问题

​		一、什么要等待2MSL

​			1.确保客户端发送的最后一个ACK报文可以到达服务端。因为这个ACK可能丢失，丢失后建立重传机制，重新启动时间等待计时器。如果不等待2MSL，一旦丢包，服务端将不能正常断开连接

​			2.等待所有报文失效。ACK最大存活时间+FIN最大存活时间=2MSL。等待2MSL确保老报文失效，防止老报文和新报文产生冲突

​		二、为什么三次握手不是两次握手

​			1.因为TCP协议是全双工的模式，三次握手是希望客户端和服务端都能收到对端请求报文上的seq序号进行确认。如果只进行两次握手，那只有服务端能收到客户端的seq序号并发送确认报文，而服务端无法收到客户端对seq序号的确认报文。

​			2.防止因为网络延迟的过期请求报文到达服务端导致开启单向连接。如果采用两次握手，客户端发送的请求报文A因为网络延时导致无法到达。客户端重传后成功连接并成功断开。当报文A到达服务端，服务端发送确认报文后开启连接，导致产生单向连接，从而浪费资源。

​		三、为什么四次挥手不是三次挥手

​			每一次断开请求报文需要对应一次请求确认报文。断开请求报文是表明我端已经没有数据需要传输，可以断开连接。客户端和服务端都需要一次断开请求来表面没有数据发送，所有要进行四次挥手，确保两端都已经无数据然后关闭连接。



## HTTP/HTTPS

#### 	HTTP概述（端口号80）

​		超文本传输协议，是TCP/IP协议组中的一个应用层的协议，是浏览器客户端和浏览器服务端通信的规则。它基于TCP实现可靠传输，是无状态的。

#### 	HTTP请求过程

​		1 DNS服务器进行域名解析，返回IP地址。HTTP客户端在80端口向HTTP服务器发起TCP连接请求。客户端和服务端有一个**套接字**进行连接。

​		2 客户端通过套接字向服务端发起HTTP请求报文。报文包含资源路径。

​		3 服务端接收报文，解析报文。从**存储器**中检索出资源对象，然后将其封装，放入响应报文并通过套接字传回给客户端，同时发送响应报文的同时发送TCP断开请求

​		4 客户端收到响应报文后，TCP断开。客户端提取出响应报文中的响应文件并检查，然后循环检查报文其他对象。

​		5 检查完毕后将响应文件展示。

#### 	HTTP请求报文

​		请求头：请求方法 请求目标 HTTP版本

​		标头：通用标头 请求标头(User-Agent Host ...) 表示标头

​		主体：单资源、多资源

#### 	HTTP响应报文

​		状态行：协议版本 状态码 状态文本

​		标头：通用标头 响应标头 表示标头

​		主体：单资源、多资源

#### 	HTTP请求方法

​		**POST** 传输实体

​		**GET ** 获取资源

​		**DELETE ** 删除文件

​		PUT 传输文件。不带验证机制，一般不用

​		HEAD 获取响应头部，不反悔主题。用于检验URL的有效性和资源更新日期

​		OPTIONS 查询支持

​		CONNECT 要求用隧道协议连接代理

​		TRACE 追踪路径

​		LINK 建立和资源的连接

​		UNLINK 断开连接关系

#### 	URL解析

​		`	http://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument`

​		协议：`http://`

​		域名：`www.example.com`

​		端口：:80

​		路径：`/path/to/myfile.html`

​		查询：`?key1=value1&key2=value2`

​		片段：`#SomewhereInTheDocument`（锚点、书签。用来标记网页浏览的位置）

#### 	HTTP优缺点

​		优点：简单灵活易扩展（结构简单，结构内容未定死）	生态和技术成熟		无状态（浏览器无需记录状态）	

​		缺点：无状态（因为无记录所以无法进行连续操作，需要不断查询身份信息）		明文（明文传输不完全）		性能（不完全适应现代互联网）

#### 	HTTPS概述（端口号443）

​		HTTPS是一个在两点之间安全的传输文字，图片，音频，视频等超文本数据的约定和规范。使用传输层安全性（TLS）或者安全套接字（SSL）进行加密。

#### 	HTTPS工作

​		加密：加密数据防止数据被监听

​		数字一致性：保证数据传输的过程中数据不被更改

​		身份验证：防止中间人攻击

#### 	Session概述

​		客户端请求服务端，服务端为该次请求开辟一块**内除空间**---session对象。弥补无状态的特征，存储**同个会话期间**的一些操作

#### 	Cookie概述

​		服务器发送的一小数据段，浏览器会对cookie进行存储，下次请求会将cookie一起发送到服务器。cookie用来验证前后两次请求是否为同一浏览器。

#### 	Cookie作用

​		会话管理：登录，购物车，游戏得分等

​		个性化：用户个性化设置

​		追踪：记录和分析用户行为

#### 	传统Token和JWT

##### 		传统Token

###### 			登录

​			1前端点击登陆，服务器验证账号密码成功		

​			2服务器生成令牌，本质是一个32位的uuid

​			3将该令牌存到数据库或redis中，key是uuid，value是userId

​			4把令牌返给客户端，客户端把令牌存在cookie中。

​			5下次请求的时候就把令牌放在请求头里带上

​			6从redis中验证该令牌是否过期

​			7获取value内容userId

​			8根据userId查询用户信息，再返回客户端

###### 			传统token优缺点

​			优点：可以隐藏真实数据	适用于分布式/微服务	安全系数高

​			缺点：存放在redis，必须依赖服务器，暂用服务器资源	效率非常低

##### 		JWT

###### 			登录

​			1用户登录

​			2认证服务器验证，颁发JWT令牌

​			3用户携带JWT令牌访问接口

​			4使用Token解析userId

​			5携带userId访问接口

​			6服务器返回数据

###### 			JWT优缺点

​			优点

​				无需服务器端存放数据，减轻服务器端的压力

​				占用带宽比较小、跨语言

​				token自身包含用户信息且无法篡改，在服务（网关）中可以自行解析校验出用户信息，对认证服务器（account-svc）压力小

​			缺点

​				JWT生成之后无法修改

​				后端无法统计生成JWT信息

​				无法吊销令牌，只能等待令牌自身过期

​				令牌长度与其包含用户信息多少正相关，传输开销较大

​				JWT是无状态的，如果别人获取到了，别人也能用

#### 	GET和POST的区别

​	1.数据传输方式：GET请求的数据通过URL参数传递，POST请求的数据通过请求体传递

​	2.请求数据长度限制：因为GET通过URL传参，所以长度不超过2048个字符。POST不受长度限制

​	3.数据安全性：GET请求的参数以明文的方式暴露在URL中。POST数据放在请求体中相对安全。

​	4.缓存方式：GET参数会被浏览器缓存，提高网站性能（如果用户在一段时间多次访问同个URL，但是服务器参数改变后用户依然收到的是之前的数据）。POST请求是每次都会向服务器发送请求。



## Websocket

#### 	概述

​		WebSocket 是一种在单个TCP连接上进行**全双工通信**的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。只需一次握手就能建立连接

#### 	优缺点

- WebSocket协议一旦建议后，互相沟通所消耗的请求头是很小的
- 服务器可以向客户端推送消息了
- 少部分浏览器不支持，浏览器支持的程度与方式有区别（IE10）

## Webpack

#### 	配置过程

​		1 初始化项目 `npm init -y`

​		2 安装依赖`webpack webpack-cli`

​		3 在项目中创建`src`目录，创建入口文件`index.js`

​		4 执行`npx webpack`进行打包

#### 	配置`webpack.config.js`

```js
modules.export = {
    mode: 'production',//打包模式 `development production`
    entry:'./src/index.js',//入口文件路径，传数组打包成一个main，传对象分别打包成key值的js文件
    output:{},//输出路径 filename打包后的文件名 path指定打包目录，绝对路径 
    module: { //loader
        rules: [{
            test: /\.css$/i, //执行css文件
            use: ["style-loader","css-loader"] //style一定要在css前面（数组从后往前执行）
        },{
            test:/\.(jpg|png|gif)$/i, //执行图片
            type:"asset/resource"
        },{ //babel配置，将js向低版本兼容
            test: /\.m?js$/,
            exclude: /(node_modules|bower_components)/,
            use: {
                loader: 'babel-loader',
                options: {
                    presets: ['@babel/preset-env']
                }
            }
        }]
    },
    plugins:[ //插件，拓展webpack功能
        new HTMLPlugins({
            template:'./src/index.html'
        })
    ],
    devtool:'inline-source-map'  //开发下的调试
}

```

#### webpack过程

​	1.读取webpack配置参数

​	2.启动webpack，创建compiler对象开始解析项目

​		compiler是全局单一对象，每次构建会生成compilation上下文对象，包含了此次构建的信息和。每次热更行和构建都会产生新的compilation对象。

​	3.从入口entry开始解析，找到导入的依赖模块，递归遍历，形成依赖关系树

​	4.对不同文件的依赖模块对应的loader进行编译，最终转为js文件（链式调用，前一个loader的结果会作为下一个loader的参数）

​	5.通过订阅发布模式，退出hook，让plugin监听这些钩子函数进行调用。compiler暴露整个生命周期，compilation暴露更小的事件函数。

























































